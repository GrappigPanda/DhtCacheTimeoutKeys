package message_handler

import (
        "fmt"
        "sync"
)

type MessageHandler struct {
        AddKeyChannel chan *KeyValPair
        RemoveKeyChannel chan *KeyValPair
        messageResponseStore *map[string]chan string
        sync.RWMutex
}

type KeyValPair struct {
        Key string
        Value chan string
        ResponseChannel chan (chan string)
        sync.RWMutex
}

func NewMessageHandler() *MessageHandler {
        addKeyChan := make(chan *KeyValPair)
        removeKeyChan := make(chan *KeyValPair)
        messageStore := make(map[string]chan string)

        msgHandler := MessageHandler{
                AddKeyChannel: addKeyChan,
                RemoveKeyChannel: removeKeyChan,
                messageResponseStore: &messageStore,
        }

        // We want to make sure the processes for adding/deleting keys are
        // running right after creation
        go msgHandler.handleKeyAdds()
        go msgHandler.handleKeyDeletions()

        return &msgHandler
}

// NewKeyValPair Handles initialization of a new KeyValPair object.
func NewKeyValPair(key string, value chan string, callerResponseChan chan chan string) *KeyValPair {
        return &KeyValPair{
                Key: key,
                Value: value,
                ResponseChannel: callerResponseChan,
        }
}

// HandleKeyAdds Manages adding keys to the internal message response store
// between the receiver processes and the sender processes.
func (m *MessageHandler) handleKeyAdds() {
        var kvPair *KeyValPair

        for {
                kvPair = <-m.AddKeyChannel

                m.Lock()
                if _, keyExists := (*m.messageResponseStore)[kvPair.Key]; keyExists {
                        m.Unlock()
                        m.handleKeyConflict(kvPair)
                        continue
                } else {
                        (*m.messageResponseStore)[kvPair.Key] = kvPair.Value
                }
                m.Unlock()

        }
}

// HandleKeyDeletions Handles everything associated with having to delete a
// key.
func (m *MessageHandler) handleKeyDeletions() {
        var kvPair *KeyValPair

        for {
                kvPair = <-m.RemoveKeyChannel

                m.Lock()
                value, keyExists := (*m.messageResponseStore)[kvPair.Key]
                if keyExists {
                        delete((*m.messageResponseStore), kvPair.Key)
                }
                m.Unlock()

                go kvPair.sendResponse(value)
        }
}

func (kvPair *KeyValPair) sendResponse(value chan string) {
        kvPair.Lock()
        if kvPair.ResponseChannel != nil {
                fmt.Println("Sending to responding channel!")
                kvPair.ResponseChannel <- value
                kvPair.Unlock()
        }
}

// handleKeyConflicts maintains the incredibly fun role of deciding what to do
// whenever we determine that a key is in conflict. This ought to be a rare
// event, as the key is generated by creating a command, appending the current
// datetime (with nano seconds) to it, and md5 hashing that. However, there are
// potentials for where this could be an issue. As of right now, the method
// solely sets the key to the value and hopes for the best.
// TODO(ian): Figure out a better way for handling this, it's technical debt
// and not yet fully implemented.
func (m *MessageHandler) handleKeyConflict(kvPair *KeyValPair) {
        m.Lock()
        (*m.messageResponseStore)[kvPair.Key] = kvPair.Value
        m.Unlock()
        return
}

