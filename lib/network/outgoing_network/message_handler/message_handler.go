package message_handler

import (
        "fmt"
        "sync"
)

type MessageHandler struct {
        AddKeyChannel chan *KeyValPair
        RemoveKeyChannel chan *KeyValPair
        MessageResponseStore *map[string]chan string
        sync.RWMutex
}

type KeyValPair struct {
        Key string
        Value chan string
        ResponseChannel chan (chan string)
}

func NewMessageHandler() *MessageHandler {
        addKeyChan := make(chan *KeyValPair)
        removeKeyChan := make(chan *KeyValPair)
        messageStore := make(map[string]chan string)

        msgHandler := MessageHandler{
                AddKeyChannel: addKeyChan,
                RemoveKeyChannel: removeKeyChan,
                MessageResponseStore: &messageStore,
        }

        // We want to make sure the processes for adding/deleting keys are
        // running right after creation
        go msgHandler.handleKeyAdds()
        go msgHandler.handleKeyDeletions()

        return &msgHandler
}

// NewKeyValPair Handles initialization of a new KeyValPair object.
func NewKeyValPair(key string, value chan string, callerResponseChan chan chan string) *KeyValPair {
        return &KeyValPair{
                key,
                value,
                callerResponseChan,
        }
}

// HandleKeyAdds Manages adding keys to the internal message response store
// between the receiver processes and the sender processes.
func (m *MessageHandler) handleKeyAdds() {
        var kvPair *KeyValPair

        for {
                kvPair = <-m.AddKeyChannel

                m.Lock()
                if _, keyExists := (*m.MessageResponseStore)[kvPair.Key]; keyExists {
                        go m.handleKeyConflict(kvPair)
                }

                m.Unlock()
        }
}

// HandleKeyDeletions Handles everything associated with having to delete a
// key.
func (m *MessageHandler) handleKeyDeletions() {
        var kvPair *KeyValPair

        for {
                kvPair = <-m.RemoveKeyChannel

                m.Lock()
                value, keyExists := (*m.MessageResponseStore)[kvPair.Key]
                if keyExists {
                        delete((*m.MessageResponseStore), kvPair.Key)
                } else {
                        if kvPair.ResponseChannel != nil {
                                kvPair.ResponseChannel <- nil
                        }
                }

                m.Unlock()

                // If the KeyValPair was created with a ResponseChannel in
                // mind, we kno the caller wants a response in the form of the
                // value previously stored for the key.
                if kvPair.ResponseChannel != nil {
                        fmt.Println("Sending to responding channel!")
                        kvPair.ResponseChannel <- value
                }
        }
}

// handleKeyConflicts maintains the incredibly fun role of deciding what to do
// whenever we determine that a key is in conflict. This ought to be a rare
// event, as the key is generated by creating a command, appending the current
// datetime (with nano seconds) to it, and md5 hashing that. However, there are
// potentials for where this could be an issue. As of right now, the method
// solely sets the key to the value and hopes for the best.
// TODO(ian): Figure out a better way for handling this, it's technical debt
// and not yet fully implemented.
func (m *MessageHandler) handleKeyConflict(kvPair *KeyValPair) {
        m.Lock()
        (*m.MessageResponseStore)[kvPair.Key] = kvPair.Value
        m.Unlock()
}

